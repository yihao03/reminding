// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: mood.sql

package sqlc

import (
	"context"
)

const addMood = `-- name: AddMood :one
INSERT INTO mood_tracker (
    user_uid,
    mood
) VALUES ($1, $2)
RETURNING id, user_uid, mood, created_at
`

type AddMoodParams struct {
	UserUid string
	Mood    int32
}

func (q *Queries) AddMood(ctx context.Context, arg AddMoodParams) (MoodTracker, error) {
	row := q.db.QueryRow(ctx, addMood, arg.UserUid, arg.Mood)
	var i MoodTracker
	err := row.Scan(
		&i.ID,
		&i.UserUid,
		&i.Mood,
		&i.CreatedAt,
	)
	return i, err
}

const getMonthlyMoodCountByUserUid = `-- name: GetMonthlyMoodCountByUserUid :many
SELECT
    mood,
    COUNT(*) AS occurrence_count
FROM mood_tracker
WHERE user_uid = $1 AND entry_date >= NOW() - INTERVAL '30 days'
GROUP BY mood
ORDER BY occurrence_count DESC
`

type GetMonthlyMoodCountByUserUidRow struct {
	Mood            int32
	OccurrenceCount int64
}

func (q *Queries) GetMonthlyMoodCountByUserUid(ctx context.Context, userUid string) ([]GetMonthlyMoodCountByUserUidRow, error) {
	rows, err := q.db.Query(ctx, getMonthlyMoodCountByUserUid, userUid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonthlyMoodCountByUserUidRow
	for rows.Next() {
		var i GetMonthlyMoodCountByUserUidRow
		if err := rows.Scan(&i.Mood, &i.OccurrenceCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
