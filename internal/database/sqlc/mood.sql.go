// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: mood.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addMood = `-- name: AddMood :one
INSERT INTO mood_tracker (
    user_uid,
    mood
) VALUES ($1, $2)
RETURNING id, user_uid, mood, created_at
`

type AddMoodParams struct {
	UserUid string
	Mood    int32
}

func (q *Queries) AddMood(ctx context.Context, arg AddMoodParams) (MoodTracker, error) {
	row := q.db.QueryRow(ctx, addMood, arg.UserUid, arg.Mood)
	var i MoodTracker
	err := row.Scan(
		&i.ID,
		&i.UserUid,
		&i.Mood,
		&i.CreatedAt,
	)
	return i, err
}

const checkUserLoggedMoodToday = `-- name: CheckUserLoggedMoodToday :one
SELECT EXISTS(
    SELECT 1
    FROM mood_tracker
    WHERE user_uid = $1 AND created_at::DATE = CURRENT_DATE
) AS has_logged_mood_today
`

func (q *Queries) CheckUserLoggedMoodToday(ctx context.Context, userUid string) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserLoggedMoodToday, userUid)
	var has_logged_mood_today bool
	err := row.Scan(&has_logged_mood_today)
	return has_logged_mood_today, err
}

const getMonthlyMoodCountByUserUid = `-- name: GetMonthlyMoodCountByUserUid :many
SELECT
    mood,
    COUNT(*) AS occurrence_count
FROM mood_tracker
WHERE user_uid = $1 AND created_at >= $2
GROUP BY mood
ORDER BY occurrence_count DESC
`

type GetMonthlyMoodCountByUserUidParams struct {
	UserUid   string
	CreatedAt pgtype.Timestamptz
}

type GetMonthlyMoodCountByUserUidRow struct {
	Mood            int32
	OccurrenceCount int64
}

func (q *Queries) GetMonthlyMoodCountByUserUid(ctx context.Context, arg GetMonthlyMoodCountByUserUidParams) ([]GetMonthlyMoodCountByUserUidRow, error) {
	rows, err := q.db.Query(ctx, getMonthlyMoodCountByUserUid, arg.UserUid, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonthlyMoodCountByUserUidRow
	for rows.Next() {
		var i GetMonthlyMoodCountByUserUidRow
		if err := rows.Scan(&i.Mood, &i.OccurrenceCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
